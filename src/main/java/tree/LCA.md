## 최소 공통 조상
LCA: lowest common ancestor
최소 공통 조상이란 트리 그래프에서 임의의 두 노드를 선택했을 떄 처음으로 만나게 되는 공통 조상을 말한다.

구하는 방법이 2가지가 있음(일반 <-> 빠른)

## 일반적 방법
lca 문제는 트리의 높이에 민감하다.
이 때 트리의 높이가 그렇게 크지 않다면, 즉 데이터가 적어 시간복잡도에서 다소 자유롭다면 일반적 방법을 사용해도 됨!

일반적 방법에서는 루트부터 탐색(bfs, dfs)을 통해 각 노드의 부모 노드와 깊이를 저장!
이 때 루트의 깊이가 1이라고 설정! (0으로 설정해도 무관)
트리의 특징으로 인해서 바로 직전 탐색노드가 부모 노드가 됨!

그다음 선택된 노드의 깊이가 다를 경우 깊이가 깊은 노드를 1개씩 위로 올려서 같은 깊이가 될때까지 반복

깊이가 같을 때 두 노드가 다른면 둘다 위로!
같으면 탐색 종료!

boj 11437이 일반적 방법으로 충분히 풀 수 있는 대표적 문제이다!!

## 빠르게빠르게 ~~
일반 방법론에서는 1. 깊이 맞춰주기, 2. 같은 노드찾기 이 두가지 과정에서 노드의 높이를 한칸씩 위로 올려준다.

그런데 빠른 방법에서는 노드의 depth를 2^k씩 올라가 비교하는 방식이다.
이를 위해서는 배열에 parent노드 뿐만 아니라, 2^k 번째 위치에 존재하는 노드까지 저장해놓아야 한다.

1. 부모 노드 저장 배열 만들기

parent[k][n] = n번 노드의 2^k 번째 부모 노드 번호
이 배열의 점화식은 다음과 같다.
parent[k][n] = parent[k-1][p[k-1][n]]
즉 n번째 노드의 2^k번째 부모 노드 번호는
n번째 노드의 2^(k-1)번째 부모 노드의 2^(k-1)번째 부모 노드이다.

이게 무슨 쌉소리일까?

실제 숫자를 가지고 이해해보자.
p[2][5]의 의미는 5번 노드의 4번째 부모를 말한다.
이를 점화식으로 다시 나타내면
p[2][5] = p[2-1][p[2-1][5]] = p[1][p[1][5]]

p[1][5]는 p의 2번째 부모노드이고,
p의 2번째 부모노드의 2번째 부모노드라고 하니 
p의 4번째 부모 노드가 되는것이다.

그리고 배열에서 k는 트리의 깊이 > 2^k를 만족하는 최대값이다.
즉 트리의 루트의 높이가 5인 트리에서 k는 2가 될 것이다.

걍 외워 병신아



