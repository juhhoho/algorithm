## 위상 정렬
boj1766 참고..

위상정렬: 노드 순서 with 사이클 x, 답 유일 x

중요!! 진입차수 배열, 선행 리스트
진입차수 배열: int[] indegree = new int[n+1];
선행 리스트: ArrayList<Integer>[] graph = new ArrayList[n+1];

before -> after에 대해...
1. indegree[after]++;
2. graph[before].add(after);
이것만 기억하자!!


(1)
**진입 차수**: 자기자신을 가리키는 에지의 수
1 -> 3
2 -> 3
3의 진입 차수는 2이다

indegree [0, 0, 2]
graph 
{
1: [3]
2: [3]
3:
}

이를 기반으로 큐를 돌려보자.
처음에 진입차수가 0인 1,2를 큐에 넣고 
1부터 빼봐
그럼 1과 인접한건 3.
3의 indegree인 2 에서 1을 빼주면 1
-> [0, 0, 1]
여전히 진입차수가 0보다 크니까 넘어가
그아므큐에서 2를 뺴고 같은 작업 
그다음에는 3의 진입차수가 0이 되어 큐에 들어감


(2)
사이클이 없으므로 진입차수가 0인 노드가 무조건 존재함
그 노드를 start node로 선택하고 정렬 배열에 저장함
그 다음 인접리스트에서 선택된 노드가 가리키는 노드들의 진입차수를 1씩 뺌

(3)
그 다음 진입차수가 0이 되는 노드에 대해서 (2)의 과정을 반복
이 때 진입차수가 0이되는 노드가 동시에 여러개 있을 수 있기 때문에 답이 여러개 있을 수 있음